@using System.Globalization
@using System.Linq
@using System.Threading
@using KonciergeUi.Client.Shared
@using KonciergeUi.Client.State
@using KonciergeUI.Core.Abstractions
@using KonciergeUI.Models.Forwarding
@using KonciergeUI.Translations.Services
@inherits LayoutComponentBase

@inject UiState Ui;
@inject ILocalizationService L;
@inject NavigationManager _nav;
@inject IPortForwardingService _fwd;

@implements IDisposable
@implements IAsyncDisposable

<MudAppBar Elevation="1">
    <MudStack AlignItems="AlignItems.Center" Spacing="3" Row>
    <!-- Left: logo + name -->
    <MudIcon Icon="@KonciergeIcons.Filled.Logo"
             Style="font-size: 2rem;"
             />
    <MudText Typo="Typo.body1" Style="font-size: x-large; font-weight: bold" Class="mud-appbar-title">
        @L.Navigation["AppName"]
    </MudText>
    </MudStack>
    <!-- Center: navigation -->
    <MudSpacer/>
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">

        <MudButton Color="Color.Info" Variant="@GetVariant("")" StartIcon="@KonciergeIcons.Outlined.Resources" Href="/">@L.Navigation["NavResources"]</MudButton>
        <MudButton Color="Color.Info" Variant="@GetVariant("templates")" StartIcon="@KonciergeIcons.Outlined.Templates" Href="/templates">@L.Navigation["NavTemplates"]</MudButton>
        
        @if (_fwdCount > 0)
        {
            <MudBadge Content="@_fwdCount" Color="Color.Secondary" Overlap="true" Class="mx-6 my-4">
                <MudButton Color="Color.Info" Variant="@GetVariant("activeforwards")" StartIcon="@KonciergeIcons.Outlined.ActiveForwards" Href="/activeforwards">@L.Navigation["NavForwards"]</MudButton>
            </MudBadge>
        }
        else
        {
            <MudButton Color="Color.Info" Variant="@GetVariant("activeforwards")" StartIcon="@KonciergeIcons.Outlined.ActiveForwards" Href="/activeforwards">@L.Navigation["NavForwards"]</MudButton>

        }
        


    </MudStack>
    <MudSpacer/>

    <!-- Right: language selector + theme switch -->
    <MudIconButton Icon="@Icons.Material.Filled.Translate"
                   Color="Color.Primary"
                   OnClick="ToggleLanguageMenu"

                   @ref="_langButtonRef"/>
    <MudMenu AnchorOrigin="Origin.BottomRight"
             TransformOrigin="Origin.TopRight"
             Open="@_langMenuOpen"
             CloseMenuOnItemClick="true"
             OnClose="() => _langMenuOpen = false"
             ActivatorContent="@(builder => builder.AddContent(0, string.Empty))"
             AnchorEl="@_langButtonRef">
        <MudMenuItem Icon="@KonciergeIcons.Flags.Uk" OnClick="@(() => ChangeLanguage("en"))">English</MudMenuItem>
        <MudMenuItem Icon="@KonciergeIcons.Flags.Italy" OnClick="@(() => ChangeLanguage("it"))">Italiano</MudMenuItem>
    </MudMenu>

    <MudIconButton Icon="@(_isDark ? Icons.Material.Filled.DarkMode : Icons.Material.Filled.LightMode)"
                   Color="Color.Primary"
                   OnClick="@ToggleTheme"/>
</MudAppBar>

@code {
    private bool _langMenuOpen;
    private MudIconButton _langButtonRef = default!;

    [Parameter] 
    public bool _isDark { get; set; }

    [Parameter] 
    public EventCallback OnThemeChangedAsync { get; set; }


    private int _fwdCount;
    private PeriodicTimer? _forwardCountTimer;
    private CancellationTokenSource? _forwardCountCts;
    private Task? _forwardCountLoopTask;
    
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _nav.LocationChanged += OnLocationChanged;
        Ui.LanguageChanged += OnLanguageChanged;

        await RefreshForwardCountAsync();
        _forwardCountCts = new CancellationTokenSource();
        _forwardCountLoopTask = RunForwardCountLoopAsync(_forwardCountCts.Token);
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }
    
    private void OnLanguageChanged(object? sender, string culture)  // ← THIS METHOD
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _nav.LocationChanged -= OnLocationChanged;
        Ui.LanguageChanged -= OnLanguageChanged;

        _forwardCountCts?.Cancel();
        _forwardCountTimer?.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        Dispose();

        if (_forwardCountLoopTask is not null)
        {
            try
            {
                await _forwardCountLoopTask;
            }
            catch (OperationCanceledException)
            {
                // ignore cancellation
            }
        }

        _forwardCountCts?.Dispose();
    }

    private string CurrentPath => _nav.ToBaseRelativePath(_nav.Uri); 

    private Variant GetVariant(string href) 
        => CurrentPath == href ? Variant.Filled : Variant.Text;
    private async Task ToggleTheme()
    {
        _isDark = !_isDark;
       await OnThemeChangedAsync.InvokeAsync();
    }

    private void ToggleLanguageMenu()
    {
        _langMenuOpen = !_langMenuOpen;
    }

    private void ChangeLanguage(string culture)
    {
        Ui.CurrentLanguage = culture;           // persists to preferences


        _langMenuOpen = false;
    }

    private async Task RunForwardCountLoopAsync(CancellationToken token)
    {
        _forwardCountTimer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        try
        {
            while (await _forwardCountTimer.WaitForNextTickAsync(token))
            {
                await RefreshForwardCountAsync();
            }
        }
        catch (OperationCanceledException)
        {
            // expected when disposing
        }
    }

    private Task RefreshForwardCountAsync()
    {
        var runningTemplates = _fwd.GetAllRunningTemplates();
        var currentCount = 0;

        foreach (var template in runningTemplates)
        {
            currentCount += template.Forwards.Count(x => x.Status == Enums.ForwardStatus.Running);
        }

        if (currentCount != _fwdCount)
        {
            _fwdCount = currentCount;
            return InvokeAsync(StateHasChanged);
        }

        return Task.CompletedTask;
    }

}