@using KonciergeUI.Models.Kube
@using KonciergeUI.Models.Security
@using KonciergeUi.Client.Components.Layout.Fields
@using KonciergeUi.Client.Components.Layout.Views
@using KonciergeUi.Client.Shared
@using KonciergeUI.Core.Abstractions
@using KonciergeUI.Models.Forwarding

@inject ISnackbar _snackbar
@inject IPortForwardingService _fwdService;

@implements IAsyncDisposable

<MudCard Outlined="false">
    <MudStack>
    <MudStack AlignItems="AlignItems.Center" Row>
        <MudStack>
            <MudStack AlignItems="AlignItems.Center" Row>
                @if (_instance.Definition.ResourceType == Enums.ResourceType.Pod)
                {
                    <MudIcon Icon="@KonciergeIcons.Outlined.Pod" Size="Size.Small" Color="Color.Primary"/>
                }
                else
                {
                    <MudIcon Icon="@KonciergeIcons.Outlined.Service" Size="Size.Small" Color="Color.Secondary"/>

                }
                <MudText Style="font-family: monospace;" Typo="Typo.body1">@_instance.Definition.ResourceName</MudText>
                <RunningForwardStatus _status="_instance.Status"/>
            </MudStack>
            <MudStack AlignItems="AlignItems.Center" Row>

                <MudText Typo="Typo.body2">@($"Source: ")</MudText>
                <MudText Style="font-family: monospace;" Typo="Typo.body2">@($"{_cluster.ContextName}:{_instance.Definition.TargetPort}")</MudText>

                <MudText Typo="Typo.body2">@($"Destination: ")</MudText>
                <MudText Style="font-family: monospace;" Typo="Typo.body2">@($"localhost:{_instance.BoundLocalPort ?? _instance.Definition.LocalPort}")</MudText>

                <MudText Typo="Typo.body2">@($"Protocol: ")</MudText>
                <MudText Style="font-family: monospace;" Typo="Typo.body2">@($"{_instance.Definition.Protocol.ToString().ToUpper()}")</MudText>
            </MudStack>
            @if (_instance.ResolvedSecrets.Any())
            {
                <MudStack AlignItems="AlignItems.Center" Row>

                    <MudText Typo="Typo.body2">@($"Links: ")</MudText>

                    @foreach (var secret in _instance.ResolvedSecrets)
                    {
                        <MudTooltip Text="@secret.Value">
                            <MudChip T="string" OnClose="(() => OnCopyClicked(secret))" Icon="@GetLinkedIcon(secret)" CloseIcon="@Icons.Material.Filled.ContentCopy" IconColor="Color.Info">@($"{@secret.Reference.Key}")</MudChip>
                        </MudTooltip>



                    }

                </MudStack>
            }
        </MudStack>
        <MudSpacer/>
        
        <MudIconButton OnClick="(() => OnCopyLogClicked(_logs))"  Icon="@Icons.Material.Filled.ContentCopy"/>
        <MudIconButton OnClick="ShowLog" Icon="@Icons.Material.Filled.Terminal"/>
        @if (_instance.Status != Enums.ForwardStatus.Stopped)
        {
            <MudButton StartIcon="@Icons.Material.Outlined.StopCircle" Color="Color.Error" OnClick="StopForward">Stop Forward</MudButton>
        }
        else
        {
            <MudButton StartIcon="@Icons.Material.Outlined.Start" Color="Color.Success" OnClick="StartForward">Start Forward</MudButton>

        }
    </MudStack>
    @if (_showLog)
    {
        
        <Output _logs="@_logs"></Output>    }
    </MudStack>
</MudCard>
@code {
    [Parameter]
    public ForwardInstance _instance { get; set; }
    [Parameter]
    public ClusterConnectionInfo _cluster { get; set; }
    private System.Timers.Timer _logRefreshTimer;

    private bool _showLog = false;


    [Parameter] 
    public EventCallback<Guid> OnForwardRemoveAsync { get; set; }

    private List<string> _logs = new();

    
    protected override async Task OnInitializedAsync()
    {
        _logRefreshTimer = new System.Timers.Timer(1000); // Refresh ogni 1 secondo
        _logRefreshTimer.Elapsed += async (s, e) => await RefreshLogs();
        _logRefreshTimer.AutoReset = true;
        _logRefreshTimer.Start();
    }

    private async Task RefreshLogs()
    {
        try
        {
            var newLogs = await _fwdService.GetForwardLogsAsync(_instance.Id);
            _logs = newLogs.ToList();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            // Handle error
        }
    }

    private async Task ShowLog(MouseEventArgs arg)
    {
        _showLog = !_showLog;
        if (_showLog)
        {
            await RefreshLogs();
        }
        StateHasChanged();
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        _logRefreshTimer?.Dispose();
    }
    
    
    private async Task RemoveClicked()
    {
        await OnForwardRemoveAsync.InvokeAsync(_instance.Definition.Id);
    }

    private async Task OnCopyClicked(ResolvedSecret s)
    {
        try
        {
            await Clipboard.Default.SetTextAsync(s.Value);
            _snackbar.Add("Added to Clipboard", Severity.Info);
        }
        catch
        {
            _snackbar.Add("Failed to copy to clipboard", Severity.Error);
        }
    }

    private async Task OnCopyLogClicked(List<string> s)
    {
        try
        {
            await Clipboard.Default.SetTextAsync(String.Join(Environment.NewLine, s));
            _snackbar.Add("Added to Clipboard", Severity.Info);
        }
        catch
        {
            _snackbar.Add("Failed to copy to clipboard", Severity.Error);
        }
    }
    private string? GetLinkedIcon(ResolvedSecret rs)

    {

        switch (rs.Reference.SourceType)
        {
            case SecretSourceType.Secret:
                return Icons.Material.Filled.Key;
            case SecretSourceType.ConfigMap:
                return Icons.Material.Filled.Settings;
            default:
                return Icons.Material.Filled.Settings;
        }



    }

    private async Task StopForward(MouseEventArgs arg)
    {
        var res= await _fwdService.StopForwardAsync(_instance.Id);
        StateHasChanged();

    }
    
    private async Task StartForward(MouseEventArgs arg)
    {
        var res= await _fwdService.StartForwardAsync(_instance.Id);
    StateHasChanged();

    }

    

}