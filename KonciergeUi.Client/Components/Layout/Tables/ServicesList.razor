@using KonciergeUi.Client.Components.Layout.Modals
@using KonciergeUi.Client.Shared
@using KonciergeUI.Models.Kube
@using KonciergeUI.Core.Abstractions
@using KonciergeUI.Models.Forwarding
@using KonciergeUi.Client.State
@using KonciergeUI.Translations.Services
@using System
@inject IKubeRepository KubeRepo
@inject IDialogService DialogService
@inject UiState _ui
@inject ILocalizationService L
<MudPaper Elevation="2" Class="pa-4">
    <MudTable Items="@_filteredServices" 
              Hover="true" 
              Dense="true" 
              Loading="@_isLoading"
              LoadingProgressColor="Color.Primary"
              FixedHeader="true"
              >
        
        <ToolBarContent>
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@KonciergeIcons.Outlined.Service" Class="mr-2" />
                @L.Resources["tab_services"] (@_services.Count)
            </MudText>
            <MudSpacer />
            
            <!-- Namespace filter -->
            <MudSelect T="string"
                       MultiSelection="true"
                       Clearable="true"
                       SelectedValues="@_ui.SelectedNamespaces"
                       SelectedValuesChanged="@(values => OnNamespacesChanged(values))"
                       Label="Namespace" 
                       Variant="Variant.Outlined" 
                       Dense="true"
                       Class="mr-2"
                       Style="min-width: 200px;"
                       MultiSelectionTextFunc="@(new Func<List<string>, string>(GetNamespaceSelectionText))">
                @foreach (var ns in _namespaces)
                {
                    <MudSelectItem T="string" Value="@ns">@ns</MudSelectItem>
                }
            </MudSelect>

            <!-- Type filter -->
            <MudSelect T="string"
                       MultiSelection="true"
                       Clearable="true"
                       SelectedValues="@_ui.SelectedTypes"
                       SelectedValuesChanged="@(values => OnTypesChanged(values))"
                       Label="Type" 
                       Variant="Variant.Outlined" 
                       Dense="true"
                       Class="mr-2"
                       Style="min-width: 200px;"
                       MultiSelectionTextFunc="@(new Func<List<string>, string>(GetTypeSelectionText))">
                @foreach (var type in Enum.GetValues<ServiceType>())
                {
                    <MudSelectItem T="string" Value="@type.ToString()">@type</MudSelectItem>
                }
            </MudSelect>

            <!-- Search -->
            <MudTextField T="string" Value="@_ui.SearchString"
                          ValueChanged="@(value => OnSearchChanged(value))"
                          Placeholder="Search services..." 
                          Adornment="Adornment.Start" 
                          AdornmentIcon="@Icons.Material.Filled.Search" 
                          IconSize="Size.Medium"
                          Variant="Variant.Outlined"
                          Dense="true"
                          Immediate="true"
                          Class="mr-2"
                          Style="min-width: 200px;" />

            <!-- Refresh button -->
            <MudTooltip Text="Refresh">
                <MudIconButton Icon="@Icons.Material.Filled.Refresh" 
                               Color="Color.Primary" 
                               OnClick="RefreshAsync"
                               Disabled="@_isLoading" />
            </MudTooltip>
        </ToolBarContent>

        <HeaderContent>
            <MudTh>Name</MudTh>
            <MudTh>Namespace</MudTh>
            <MudTh>Type</MudTh>
            <MudTh>Ports</MudTh>
            <MudTh Style="text-align: right;">Actions</MudTh>
        </HeaderContent>

        <RowTemplate>
            <MudTd DataLabel="Name">
                <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                    <MudIcon Icon="@KonciergeIcons.Outlined.Service" Size="Size.Small" Color="Color.Secondary" />
                    <MudText Typo="Typo.body2" Style="font-family: monospace;">@context.Name</MudText>
                </MudStack>
            </MudTd>
            
            <MudTd DataLabel="Namespace">
                <MudChip T="string" Size="Size.Small" Color="Color.Default" Variant="Variant.Text">
                    @context.Namespace
                </MudChip>
            </MudTd>
            
            <MudTd DataLabel="Type">
                <MudChip T="string" Size="Size.Small"
                         Color="@GetServiceTypeColor(context.Type)" 
                         Variant="Variant.Filled">
                    @context.Type
                </MudChip>
            </MudTd>
            
            <MudTd DataLabel="Ports">
                @if (context.Ports.Any())
                {
                    <MudStack Row="true" Spacing="0">
                        @foreach (var port in context.Ports.Take(3))
                        {
                            <MudTooltip Text="@($"{port.Protocol} - Target: {port.TargetPort}")">
                                <MudChip T="string" Size="Size.Small" 
                                         Variant="Variant.Text" 
                                         Color="Color.Info"
                                         Style="margin-right: 4px;">
                                    @port.Name: @port.Port->@port.TargetPort/@port.Protocol
                                </MudChip>
                            </MudTooltip>
                        }
                        @if (context.Ports.Count > 3)
                        {
                            <MudChip T="string" Size="Size.Small" Variant="Variant.Text">
                                +@(context.Ports.Count - 3)
                            </MudChip>
                        }
                    </MudStack>
                }
                else
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                }
            </MudTd>
            <MudTd DataLabel="Actions">
                @if (context.Ports.Any())
                {
                    <MudStack Row="true" Spacing="0">
                        @foreach (var port in context.Ports)
                        {
                            <MudTooltip Text="@($"{port.Name}: {port.Protocol}")">
                                <MudChip T="string" Size="Size.Small"
                                         Variant="Variant.Filled"
                                         Disabled="@IsForwardDisabled(port, context)"                                         OnClick="() => OpenForwardCreate(port, context)"                                         Color="Color.Info"
                                         Style="margin-right: 4px;">
                                    Forward :@port.Port
                                </MudChip>
                            </MudTooltip>
                        }
                       
                    </MudStack>
                }
                else
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                }
            </MudTd>
            
            
        </RowTemplate>

        <NoRecordsContent>
            <MudAlert Severity="Severity.Info" Class="my-4">
                @if (_isLoading)
                {
                    <MudText>Loading services...</MudText>
                }
                else if (!string.IsNullOrEmpty(_ui.SearchString) || _ui.SelectedNamespaces.Any() || _ui.SelectedTypes.Any())
                {
                    <MudText>No services match the current filters.</MudText>
                }
                else
                {
                    <MudText>No services found in this cluster.</MudText>
                }
            </MudAlert>
        </NoRecordsContent>
                <PagerContent>
            <MudTablePager PageSizeOptions="@(new int[] { 15, 30, 50, int.MaxValue })" />
        </PagerContent>
    </MudTable>
</MudPaper>

@code {
    private List<ServiceInfo> _services = new();
    private List<ServiceInfo> _filteredServices = new();
    private List<string> _namespaces = new();
    private bool _isLoading = false;



    [Parameter]
    public ClusterConnectionInfo? Cluster { get; set; }

    [Parameter]
    public EventCallback<PortForwardDefinition> OnCreateForwardClicked { get; set; }
    [Parameter]
    public IReadOnlyCollection<PortForwardDefinition>? ExistingForwards { get; set; }



 private bool _hasLoaded = false;
    private ClusterConnectionInfo? _previousCluster;



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Cluster != null && !_hasLoaded)
        {
            _hasLoaded = true;
            await LoadServicesAsync();
        }
    }

    protected override void OnParametersSet()
    {
        if (Cluster == null)
        {
            _services.Clear();
            _filteredServices.Clear();
            _namespaces.Clear();
            _hasLoaded = false;
            _previousCluster = null;
            ClearFilters();
        }
        else if (_previousCluster?.Id != Cluster.Id)
        {
            // Cluster changed, trigger reload and clear filters
            _hasLoaded = false;
            _previousCluster = Cluster;
            ClearFilters();
        }
    }

    private void ClearFilters()
    {
        _ui.SelectedNamespaces = new HashSet<string>();
        _ui.SelectedTypes = new HashSet<string>();
        _ui.SearchString = null;
    }

    private void OnNamespacesChanged(IEnumerable<string> values)
    {
        _ui.SelectedNamespaces = values;
        ApplyFilters();
    }

    private void OnTypesChanged(IEnumerable<string> values)
    {
        _ui.SelectedTypes = values;
        ApplyFilters();
    }

    private void OnSearchChanged(string value)
    {
        _ui.SearchString = value;
        ApplyFilters();
    }

    private string GetNamespaceSelectionText(List<string> selectedValues)
    {
        if (!selectedValues.Any())
            return "All namespaces";
        if (selectedValues.Count == 1)
            return selectedValues.First();
        return $"{selectedValues.Count} namespaces";
    }

    private string GetTypeSelectionText(List<string> selectedValues)
    {
        if (!selectedValues.Any())
            return "All types";
        if (selectedValues.Count == 1)
            return selectedValues.First();
        return $"{selectedValues.Count} types";
    }

    private async Task LoadServicesAsync()
    {
        if (Cluster == null) return;

        _isLoading = true;
        StateHasChanged();

        try
        {
            _services = await KubeRepo.ListServicesAsync(Cluster);
            _namespaces = _services.Select(s => s.Namespace).Distinct().OrderBy(n => n).ToList();
            ApplyFilters();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load services: {ex.Message}");
            _services.Clear();
            _filteredServices.Clear();
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    public async Task RefreshAsync()
    {
        await LoadServicesAsync();
    }

    private void ApplyFilters()
    {
        _filteredServices = _services.Where(service =>
        {
            // Namespace filter (multi-select)
            if (_ui.SelectedNamespaces.Any() && !_ui.SelectedNamespaces.Contains(service.Namespace))
                return false;

            // Type filter (multi-select)
            if (_ui.SelectedTypes.Any() && !_ui.SelectedTypes.Contains(service.Type.ToString()))
                return false;

            // Search filter
            if (!string.IsNullOrEmpty(_ui.SearchString))
            {
                var search = _ui.SearchString.ToLowerInvariant();
                return service.Name.ToLowerInvariant().Contains(search) ||
                       service.Namespace.ToLowerInvariant().Contains(search);
            }

            return true;
        })
        .OrderBy(s => s.Namespace)
        .ThenBy(s => s.Name)
        .ToList();
    }

    private async Task OpenForwardCreate(ServicePort cp, ServiceInfo ser)
    {
        var parameters = new DialogParameters<CreateForwardDialog>
        {
            { x => x._servicePort, cp },
            { x => x._namespace, ser.Namespace },
            { x => x._resourceName, ser.Name },
            { x => x._kind, Enums.ResourceType.Service },
            { x => x._cluster, Cluster },
           
        };

        var options = new DialogOptions() { CloseButton = true, MaxWidth = MaxWidth.Medium };

        var dialog= await DialogService.ShowAsync<CreateForwardDialog>("Create Forward", parameters, options);
        
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            //In a real world scenario we would reload the data from the source here since we "removed" it in the dialog already.
            var xxx = result.Data as PortForwardDefinition;
            await OnCreateForwardClicked.InvokeAsync(xxx);
        }

    }

    private bool IsForwardDisabled(ServicePort port, ServiceInfo service)
    {
        if (ExistingForwards is null)
        {
            return false;
        }

        return ExistingForwards.Any(fwd =>
            fwd.ResourceType == Enums.ResourceType.Service &&
            string.Equals(fwd.Namespace, service.Namespace, StringComparison.OrdinalIgnoreCase) &&
            string.Equals(fwd.ResourceName, service.Name, StringComparison.OrdinalIgnoreCase) &&
            fwd.TargetPort == port.Port);
    }

    private Color GetServiceTypeColor(ServiceType type) => type switch
    {
        ServiceType.ClusterIP => Color.Primary,
        ServiceType.NodePort => Color.Info,
        ServiceType.LoadBalancer => Color.Success,
        ServiceType.ExternalName => Color.Secondary,
        _ => Color.Default
    };
}
